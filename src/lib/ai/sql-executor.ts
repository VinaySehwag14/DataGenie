// This file safely executes SQL generated by AI
// SECURITY IS CRITICAL HERE!

import { createClient } from '@/lib/supabase/server'

export async function executeSafeSQL(
    sql: string,
    dataSourceId: string,
    userId: string
) {
    const supabase = await createClient()

    // SECURITY CHECK 1: Verify user owns this data source
    const { data: dataSource, error: sourceError } = await supabase
        .from('data_sources')
        .select(`
      *,
      workspaces!inner(user_id)
    `)
        .eq('id', dataSourceId)
        .single()

    if (sourceError || !dataSource) {
        throw new Error('Data source not found')
    }

    if (dataSource.workspaces.user_id !== userId) {
        throw new Error('Unauthorized access to data source')
    }

    // SECURITY CHECK 2: Validate SQL (prevent dangerous operations)
    const lowerSQL = sql.toLowerCase()

    // Block dangerous SQL keywords
    const dangerousKeywords = [
        'drop',
        'delete',
        'truncate',
        'alter',
        'insert',
        'update',
        'create',
        'grant',
        'revoke'
    ]

    for (const keyword of dangerousKeywords) {
        if (lowerSQL.includes(keyword)) {
            throw new Error(`SQL contains dangerous keyword: ${keyword}`)
        }
    }

    // SECURITY CHECK 3: Must include data_source_id filter
    if (!sql.includes(dataSourceId)) {
        throw new Error('SQL must filter by data_source_id for security')
    }

    try {
        // Execute the SQL query
        // Note: We use Supabase's RPC (Remote Procedure Call) feature
        // This is safer than direct SQL execution

        const { data, error } = await supabase.rpc('execute_sql', {
            query_text: sql
        })

        if (error) {
            // If RPC doesn't exist, try direct query (fallback)
            // This uses Supabase's query builder which is slightly safer
            const result = await supabase
                .from('data_rows')
                .select('row_data')
                .eq('data_source_id', dataSourceId)

            if (result.error) {
                throw new Error(`SQL execution failed: ${result.error.message}`)
            }

            return {
                success: true,
                data: result.data.map(row => row.row_data),
                rowCount: result.data.length
            }
        }

        return {
            success: true,
            data: data || [],
            rowCount: data?.length || 0
        }
    } catch (error: any) {
        console.error('SQL execution error:', error)

        return {
            success: false,
            error: error.message || 'Failed to execute query',
            data: [],
            rowCount: 0
        }
    }
}

// Helper: Format SQL results for display
export function formatQueryResults(results: any[], columns?: string[]) {
    if (results.length === 0) {
        return 'No results found'
    }

    // If single row with single column (aggregate result)
    if (results.length === 1) {
        const firstRow = results[0]
        const keys = Object.keys(firstRow)

        if (keys.length === 1) {
            const value = firstRow[keys[0]]

            // Format numbers nicely
            if (typeof value === 'number') {
                return value.toLocaleString('en-IN', {
                    maximumFractionDigits: 2
                })
            }

            return value
        }
    }

    // Multiple rows - return as formatted object
    return results
}
